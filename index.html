<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dream Lexicon</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #e3e4e8;
            --bg-secondary: #f5f6f8;
            --bg-card: #ffffff;
            --text-primary: #1c1c1e;
            --text-secondary: #898a8f;
            --text-tertiary: #a9aaaf;
            --divider: #d0d1d6;
            --hover: #ecedf2;
            --selected: #e0e1e6;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Helvetica Neue', sans-serif;
            background: 
                radial-gradient(ellipse at 20% 20%, rgba(210, 180, 230, 0.6) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 30%, rgba(180, 210, 245, 0.5) 0%, transparent 50%),
                radial-gradient(ellipse at 40% 70%, rgba(245, 190, 180, 0.45) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 80%, rgba(230, 215, 190, 0.5) 0%, transparent 50%),
                linear-gradient(180deg, #e0e1e6 0%, #d4d5da 100%);
            color: var(--text-primary);
            font-size: 10px;
            line-height: 1.47;
            letter-spacing: -0.016em;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            overflow: hidden;
            height: 100vh;
            margin: 0;
        }

        .header {
            background: transparent;
            position: relative;
            z-index: 100;
        }

        .header-top {
            height: 56px;
            display: flex;
            align-items: center;
            padding: 0 24px;
            gap: 32px;
            border-bottom: 1px solid var(--divider);
        }

        .logo {
            font-size: 17px;
            font-weight: 600;
            letter-spacing: -0.024em;
            color: var(--text-primary);
        }

        .header-stats {
            display: flex;
            gap: 28px;
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .stat-value {
            color: var(--text-primary);
            font-weight: 600;
            margin-left: 7px;
        }

        .universal-controls {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px 24px 18px;
            background: transparent;
        }

        .search-container {
            flex: 1;
            position: relative;
            max-width: 440px;
        }

        .universal-search {
            width: 100%;
            padding: 9px 16px;
            font-size: 14px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 10px;
            font-family: inherit;
            transition: all 0.2s;
            color: var(--text-primary);
        }

        .universal-search:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.65);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .universal-search::placeholder {
            color: var(--text-tertiary);
        }

        .sort-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }

        .sort-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            margin-right: 10px;
        }

        .universal-sort-btn {
            padding: 7px 16px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            color: var(--text-secondary);
            cursor: pointer;
            font-family: inherit;
            transition: all 0.2s;
            border-radius: 10px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .universal-sort-btn:hover {
            background: rgba(255, 255, 255, 0.65);
            color: var(--text-primary);
        }

        .universal-sort-btn.active {
            background: rgba(255, 255, 255, 0.7);
            border-color: rgba(255, 255, 255, 0.4);
            color: var(--text-primary);
        }

        .sort-direction {
            font-size: 11px;
            opacity: 0.7;
            font-weight: 600;
        }

        .columns-container {
            display: flex;
            height: calc(100vh - 56px - 54px);
            overflow: hidden;
            gap: 1px;
            background: transparent;
            padding: 0;
        }

        .column {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.28, 0.11, 0.32, 1);
            background: rgba(255, 255, 255, 0.45);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.25);
        }

        .column:last-child {
            border-right: none;
        }

        .column.collapsed {
            flex: 0 0 32px;
            min-width: 32px;
        }

        .column.expanded {
            flex: 1 1 auto;
            min-width: 600px;
        }

        .column-header {
            padding: 18px 16px;
            background: transparent;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .column-header:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .column.collapsed .column-header {
            writing-mode: vertical-lr;
            text-align: center;
            padding: 24px 10px;
        }

        .column-title {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: -0.015em;
            color: var(--text-primary);
            margin-bottom: 5px;
        }

        .column.active .column-title {
            color: var(--text-primary);
        }

        .column.collapsed .column-title {
            margin-bottom: 0;
        }

        .column-count {
            font-size: 12px;
            color: var(--text-tertiary);
            font-weight: 400;
        }

        .column.active .column-count {
            color: var(--text-secondary);
        }

        .column.collapsed .column-count {
            display: none;
        }

        .column.collapsed .items-list {
            display: none;
        }

        .items-list {
            flex: 1;
            overflow-y: auto;
            background: transparent;
        }

        .loading-indicator {
            padding: 20px;
            text-align: center;
            color: var(--gray-400);
            font-size: 8px;
        }

        .item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 4px 12px;
            cursor: pointer;
            position: relative;
        }

        .item-inner {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            padding: 7px 12px;
            border-radius: 8px;
            transition: background 0.15s;
        }

        .item:hover .item-inner {
            background: rgba(0, 0, 0, 0.05);
        }

        .item.active .item-inner {
            background: var(--selected);
        }

        .item-text {
            font-size: 12px;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 400;
            color: var(--text-primary);
            flex: 1;
        }

        .item.active .item-text {
            font-weight: 500;
        }

        .item-count {
            font-size: 12px;
            color: var(--text-tertiary);
            font-weight: 500;
            font-variant-numeric: tabular-nums;
            margin-left: auto;
        }

        .item.active .item-count {
            color: var(--text-secondary);
        }


        .dreams-view {
            flex: 1;
            overflow-y: auto;
            padding: 32px 40px;
            display: none;
            background: transparent;
        }

        .column.expanded .dreams-view {
            display: block;
        }

        .column.expanded .items-list {
            display: none;
        }

        .dreams-header {
            margin-bottom: 36px;
            padding-bottom: 22px;
            border-bottom: 1px solid var(--divider);
        }

        .selected-phrase {
            font-size: 28px;
            font-weight: 600;
            letter-spacing: -0.028em;
            margin-bottom: 12px;
            line-height: 1.15;
            color: var(--text-primary);
        }

        .dreams-meta {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 400;
        }

        .dream-card {
            margin-bottom: 28px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
        }

        .dream-card:last-child {
            margin-bottom: 0;
        }

        .dream-card-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 14px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }

        .dream-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.06em;
        }

        .dream-id {
            font-size: 12px;
            color: var(--text-tertiary);
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }

        .dream-text {
            font-size: 14px;
            line-height: 1.55;
            color: var(--text-primary);
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .highlight {
            background: linear-gradient(120deg, rgba(210, 180, 230, 0.4), rgba(180, 210, 245, 0.4));
            color: var(--text-primary);
            font-weight: 500;
            padding: 2px 4px;
            border-radius: 4px;
        }

        mark {
            background: rgba(142, 142, 147, 0.1);
            padding: 0 3px;
            border-radius: 3px;
        }

        .back-button {
            display: inline-block;
            margin-bottom: 24px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            text-transform: lowercase;
        }

        .back-button:hover {
            color: var(--text-primary);
            background: rgba(255, 255, 255, 0.65);
        }

        .poetry-btn {
            margin-left: auto;
            padding: 8px 16px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-primary);
            text-decoration: none;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            text-transform: lowercase;
        }

        .poetry-btn:hover {
            background: linear-gradient(120deg, rgba(210, 180, 230, 0.6), rgba(180, 210, 245, 0.6));
            border-color: rgba(210, 190, 235, 0.4);
            color: var(--text-primary);
        }

        .load-more-btn {
            padding: 10px 16px;
            margin: 16px;
            font-size: 8px;
            font-weight: 700;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            border: 1px solid var(--gray-700);
            background: var(--white);
            cursor: pointer;
            font-family: inherit;
            transition: all 0.15s;
            width: calc(100% - 32px);
        }

        .load-more-btn:hover {
            background: var(--black);
            color: var(--white);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.15);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.25);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-top">
            <div class="logo">Dream Lexicon</div>
            <div class="header-stats">
                <span>patterns <span class="stat-value" id="total-patterns">—</span></span>
                <span>dreams <span class="stat-value" id="total-dreams">—</span></span>
            </div>
            <a href="poetry.html" class="poetry-btn">make your own fridge poetry</a>
        </div>
        <div class="universal-controls">
            <div class="search-container">
                <input type="text" class="universal-search" placeholder="Search all patterns..." id="universal-search">
            </div>
            <div class="sort-controls">
                <span class="sort-label">Sort</span>
                <button class="universal-sort-btn active" id="sort-alphabetical" data-sort="alpha">
                    Alphabetical
                    <span class="sort-direction" id="sort-direction">↓</span>
                </button>
                <button class="universal-sort-btn" id="sort-frequency" data-sort="freq">Frequency</button>
            </div>
        </div>
    </div>

    <div class="columns-container">
        <div class="column" data-pattern="adj_noun">
            <div class="column-header">
                <div class="column-title">Adj–Noun</div>
                <div class="column-count" id="count-adj_noun">55,171</div>
            </div>
            <div class="items-list" id="list-adj_noun"></div>
            <div class="dreams-view" id="dreams-adj_noun"></div>
        </div>

        <div class="column" data-pattern="verb_noun">
            <div class="column-header">
                <div class="column-title">Verb–Noun</div>
                <div class="column-count" id="count-verb_noun">113,103</div>
            </div>
            <div class="items-list" id="list-verb_noun"></div>
            <div class="dreams-view" id="dreams-verb_noun"></div>
        </div>

        <div class="column" data-pattern="prep">
            <div class="column-header">
                <div class="column-title">Prepositional</div>
                <div class="column-count" id="count-prep">145,139</div>
            </div>
            <div class="items-list" id="list-prep"></div>
            <div class="dreams-view" id="dreams-prep"></div>
        </div>

        <div class="column" data-pattern="adverb_verb">
            <div class="column-header">
                <div class="column-title">Adverb–Verb</div>
                <div class="column-count" id="count-adverb_verb">49,161</div>
            </div>
            <div class="items-list" id="list-adverb_verb"></div>
            <div class="dreams-view" id="dreams-adverb_verb"></div>
        </div>

        <div class="column" data-pattern="temporal">
            <div class="column-header">
                <div class="column-title">Temporal</div>
                <div class="column-count" id="count-temporal">5,995</div>
            </div>
            <div class="items-list" id="list-temporal"></div>
            <div class="dreams-view" id="dreams-temporal"></div>
        </div>

        <div class="column" data-pattern="compound">
            <div class="column-header">
                <div class="column-title">Compound</div>
                <div class="column-count" id="count-compound">31,111</div>
            </div>
            <div class="items-list" id="list-compound"></div>
            <div class="dreams-view" id="dreams-compound"></div>
        </div>

        <div class="column" data-pattern="emotional">
            <div class="column-header">
                <div class="column-title">Emotional</div>
                <div class="column-count" id="count-emotional">4,433</div>
            </div>
            <div class="items-list" id="list-emotional"></div>
            <div class="dreams-view" id="dreams-emotional"></div>
        </div>
    </div>

    <!-- Supabase JS Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <script>
        // ======= CONFIGURATION =======
        // Replace these with your Supabase project credentials
        const SUPABASE_URL = 'https://ldpxwjzqaraehwvybiqe.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImxkcHh3anpxYXJhZWh3dnliaXFlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ3ODEwMDAsImV4cCI6MjA4MDM1NzAwMH0.9N7ml2HWY0I3KZ4PEGoyCqnMKRJGzYUcX6g_HuBwIgU';
        
        // Initialize Supabase client
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // ======= STATE =======
        const ITEMS_PER_PAGE = 1000; // Supabase limit per query
        let universalSort = 'alpha';
        let universalSearch = '';
        
        let columnData = {
            adj_noun: { loaded: false, hasMore: true, offset: 0, patterns: [], loading: false, aggregated: new Map() },
            verb_noun: { loaded: false, hasMore: true, offset: 0, patterns: [], loading: false, aggregated: new Map() },
            prep: { loaded: false, hasMore: true, offset: 0, patterns: [], loading: false, aggregated: new Map() },
            adverb_verb: { loaded: false, hasMore: true, offset: 0, patterns: [], loading: false, aggregated: new Map() },
            temporal: { loaded: false, hasMore: true, offset: 0, patterns: [], loading: false, aggregated: new Map() },
            compound: { loaded: false, hasMore: true, offset: 0, patterns: [], loading: false, aggregated: new Map() },
            emotional: { loaded: false, hasMore: true, offset: 0, patterns: [], loading: false, aggregated: new Map() }
        };

        // ======= SUPABASE QUERIES =======
        async function getTotalDreamsCount() {
            const { count, error } = await supabase
                .from('dreams')
                .select('*', { count: 'exact', head: true });
            
            if (error) {
                console.error('Error fetching dreams count:', error);
                return 0;
            }
            return count;
        }

        async function getPatternsByType(patternType, sortBy = 'alpha', searchQuery = '', offset = 0, limit = ITEMS_PER_PAGE) {
            // Use the fast pattern_counts materialized view
            // Only fetch one page (1000 results) at a time
                try {
                    let query = supabase
                        .from('pattern_counts')
                        .select('text_lower, display_text, count')
                    .eq('pattern_type', patternType);
                
                // Apply search filter server-side if provided
                if (searchQuery) {
                    query = query.ilike('text_lower', `%${searchQuery.toLowerCase()}%`);
                }
                
                // Apply sorting
                if (sortBy === 'freq') {
                    query = query.order('count', { ascending: false }).order('display_text', { ascending: true });
                } else if (sortBy === 'alpha_desc') {
                    query = query.order('display_text', { ascending: false });
                } else {
                    // Default to ascending alphabetical
                    query = query.order('display_text', { ascending: true });
                }
                
                // Apply pagination
                query = query.range(offset, offset + limit - 1);
                
                    const { data, error } = await query;
                    
                if (error) {
                    console.error(`Error fetching ${patternType}:`, error);
                    throw error;
                }
                
                if (!data || data.length === 0) {
                    return { results: [], total: 0, hasMore: false, dbRowsFetched: 0 };
                }
                
                // Filter out patterns starting with number or dash
                // For temporal patterns, we want to keep text-based temporal words like "yesterday", "monday", etc.
                // but filter out numeric dates, times, and other junk
                const filtered = data.filter(row => {
                    const text = row.text_lower;
                    // Filter out single characters or just punctuation
                    if (text.length <= 1) return false;
                    if (/^[-_.,:;'"\/\\*+=#&]$/.test(text)) return false;
                    
                    // For all pattern types (including temporal), filter out patterns starting with numbers or dashes
                    // This removes date/time entries like "01-01", "05", "-", etc.
                    // but keeps legitimate temporal words like "yesterday", "monday", "january", etc.
                    return !/^[0-9-]/.test(text);
                });
                
                // Convert to results format
                const results = filtered.map(row => ({
                    text: row.display_text,
                    count: row.count,
                    text_lower: row.text_lower // Keep for client-side aggregation
                }));
                
                // Determine if there's more data (based on database rows, not filtered)
                const hasMore = data.length === limit;
            
                // Return filtered results, but also the number of database rows fetched
                return { results, total: results.length, hasMore, dbRowsFetched: data.length };
            } catch (err) {
                console.error(`Exception loading ${patternType}:`, err);
                throw err;
            }
        }

        async function getTotalPatternCount(patternType) {
            // Query patterns table directly
            const { data, error } = await supabase
                .from('patterns')
                .select('text', { count: 'exact', head: false })
                .eq('pattern_type', patternType);
            
            if (error) {
                console.error('Error fetching pattern count:', error);
                return 0;
            }
            
            // Count unique texts
            const uniqueTexts = new Set(data.map(p => p.text));
            return uniqueTexts.size;
        }

        async function getDreamsByPattern(patternType, phrase, limit = 100) {
            // Use ilike to get potential matches, then filter for exact match
            // This is more efficient than fetching all patterns
            const { data: patterns, error: patternsError } = await supabase
                .from('patterns')
                .select('id, dream_id, start_pos, end_pos, text')
                .eq('pattern_type', patternType)
                .ilike('text', phrase) // This will match phrases containing the text
                .limit(1000); // Reasonable limit
            
            if (patternsError) {
                console.error('Error fetching patterns:', patternsError);
                return [];
            }
            
            // Filter for exact case-insensitive match
            const matchingPatterns = patterns.filter(p => p.text.toLowerCase() === phrase.toLowerCase());
            
            if (matchingPatterns.length === 0) {
                return [];
            }
            
            // Get unique dream IDs (limit to avoid too many IDs in the IN clause)
            const dreamIds = [...new Set(matchingPatterns.map(p => p.dream_id))].slice(0, limit);
            
            if (dreamIds.length === 0) {
                return [];
            }
            
            // Fetch the dreams in batches if needed (Supabase IN clause has limits)
            const batchSize = 100;
            let allDreams = [];
            
            for (let i = 0; i < dreamIds.length; i += batchSize) {
                const batch = dreamIds.slice(i, i + batchSize);
                const { data: dreams, error: dreamsError } = await supabase
                    .from('dreams')
                    .select('id, text')
                    .in('id', batch);
                
                if (dreamsError) {
                    console.error('Error fetching dreams batch:', dreamsError);
                    continue;
                }
                
                if (dreams) {
                    allDreams.push(...dreams);
                }
            }
            
            // Create a map of dream_id -> dream
            const dreamMap = new Map(allDreams.map(d => [d.id, d]));
            
            // Return with position info from the first matching pattern for each dream
            const result = [];
            const seenDreams = new Set();
            
            for (const pattern of matchingPatterns) {
                if (seenDreams.has(pattern.dream_id) || result.length >= limit) break;
                const dream = dreamMap.get(pattern.dream_id);
                if (dream) {
                    result.push({
                        id: dream.id,
                        text: dream.text,
                        start_pos: pattern.start_pos,
                        end_pos: pattern.end_pos
                    });
                    seenDreams.add(pattern.dream_id);
                }
            }
            
            return result;
        }

        // Helper function to merge new results with existing patterns
        // pattern_counts is already aggregated, but we merge in case of duplicates
        function mergePatternResults(existingMap, newResults) {
            newResults.forEach(row => {
                const key = row.text_lower;
                if (existingMap.has(key)) {
                    // Sum counts if duplicate (shouldn't happen with pattern_counts, but just in case)
                    existingMap.get(key).count += row.count;
                } else {
                    existingMap.set(key, {
                        text: row.text,
                        count: row.count,
                        text_lower: row.text_lower
                    });
                }
            });
        }

        // Convert aggregated map to sorted array
        function getSortedPatterns(aggregatedMap, sortBy) {
            const results = Array.from(aggregatedMap.values());
            if (sortBy === 'freq') {
                results.sort((a, b) => b.count - a.count || a.text.localeCompare(b.text));
            } else if (sortBy === 'alpha_desc') {
                results.sort((a, b) => b.text.localeCompare(a.text));
            } else {
                // Default to ascending alphabetical
                results.sort((a, b) => a.text.localeCompare(b.text));
            }
            return results;
        }

        // ======= RENDERING =======
        async function loadColumn(pattern, append = false) {
            const listEl = document.getElementById(`list-${pattern}`);
            const columnState = columnData[pattern];
            
            // Prevent concurrent loads
            if (columnState.loading) return;
            columnState.loading = true;
            
            if (!append) {
                listEl.innerHTML = '<div class="loading-indicator">Loading patterns...</div>';
                columnState.offset = 0;
                columnState.patterns = [];
                columnState.aggregated = new Map();
                columnState.hasMore = true;
            }
            
            try {
                // For initial load, keep fetching pages until we have some valid results
                // This handles cases where all results in a page are filtered out (e.g., temporal patterns starting with numbers)
                let attempts = 0;
                const maxAttempts = 20; // Prevent infinite loops
                let hasMore = true;
                
                // Only auto-fetch multiple pages on initial load (not when appending via scroll)
                if (!append) {
                    while (columnState.aggregated.size === 0 && hasMore && attempts < maxAttempts) {
                        attempts++;
                        
                        // Fetch next page from Supabase
                        const { results, total, hasMore: pageHasMore, dbRowsFetched } = await getPatternsByType(
                    pattern, 
                    universalSort, 
                    universalSearch, 
                            columnState.offset,
                            ITEMS_PER_PAGE
                        );
                        
                        // Merge with existing aggregated data
                        mergePatternResults(columnState.aggregated, results);
                        
                        // Update state - offset based on database rows fetched, not filtered results
                        columnState.offset += (dbRowsFetched !== undefined ? dbRowsFetched : results.length);
                        hasMore = pageHasMore;
                        
                        // If we have results now, break out of the loop
                        if (columnState.aggregated.size > 0) break;
                        
                        // If no results and no more data, stop
                        if (!pageHasMore) break;
                    }
                } else {
                    // For append (infinite scroll), just fetch one page
                    const { results, total, hasMore: pageHasMore, dbRowsFetched } = await getPatternsByType(
                        pattern, 
                        universalSort, 
                        universalSearch,
                        columnState.offset,
                        ITEMS_PER_PAGE
                    );
                    
                    // Merge with existing aggregated data
                    mergePatternResults(columnState.aggregated, results);
                
                    // Update state - offset based on database rows fetched, not filtered results
                    columnState.offset += (dbRowsFetched !== undefined ? dbRowsFetched : results.length);
                    hasMore = pageHasMore;
                }
                
                columnState.hasMore = hasMore;
                columnState.loaded = true;
                
                // Get all patterns sorted
                const allPatterns = getSortedPatterns(columnState.aggregated, universalSort);
                columnState.patterns = allPatterns;
                
                // Render the list
                renderPatternList(pattern, allPatterns, append);
                
                // Counts are now hardcoded in HTML, no need to update dynamically
            } catch (error) {
                console.error(`Error loading column ${pattern}:`, error);
                console.error('Error details:', error.message, error.stack);
                listEl.innerHTML = `<div class="loading-indicator">Error loading patterns: ${error.message || 'Unknown error'}</div>`;
            } finally {
                columnState.loading = false;
            }
        }

        function renderPatternList(pattern, patterns, append = false) {
            const listEl = document.getElementById(`list-${pattern}`);
            
            if (!append) {
                listEl.innerHTML = '';
                
                // Set up scroll listener once per column
                if (!listEl._scrollHandler) {
                    listEl._scrollHandler = () => {
                        const scrollBottom = listEl.scrollTop + listEl.clientHeight;
                        const threshold = listEl.scrollHeight - 100;
                        const columnState = columnData[pattern];
                        
                        // Load more when near bottom, if there's more data and not already loading
                        if (scrollBottom >= threshold && columnState.hasMore && !columnState.loading) {
                                loadColumn(pattern, true);
                        }
                    };
                    listEl.addEventListener('scroll', listEl._scrollHandler);
                }
            }
            
            // Remove loading indicator if present
            const loadingIndicator = listEl.querySelector('.loading-indicator');
            if (loadingIndicator) {
                loadingIndicator.remove();
            }
            
            // Determine which patterns to render
            // When appending, only render new items
            const startIdx = append ? (listEl.children.length) : 0;
            const patternsToRender = patterns.slice(startIdx);
            
            patternsToRender.forEach(({ text, count }) => {
                const div = document.createElement('div');
                div.className = 'item';
                
                const innerDiv = document.createElement('div');
                innerDiv.className = 'item-inner';
                
                const textEl = document.createElement('div');
                textEl.className = 'item-text';
                textEl.textContent = text;
                
                const countEl = document.createElement('div');
                countEl.className = 'item-count';
                countEl.textContent = count;
                
                innerDiv.appendChild(textEl);
                innerDiv.appendChild(countEl);
                
                div.appendChild(innerDiv);
                
                div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const anyExpanded = document.querySelector('.column.expanded');
                    if (anyExpanded) {
                        collapseAll();
                        setTimeout(() => expandColumn(pattern, text), 50);
                    } else {
                        expandColumn(pattern, text);
                    }
                });
                
                listEl.appendChild(div);
            });
            
            // Show loading indicator at bottom if there's more to load
            if (columnData[pattern].hasMore && listEl.querySelector('.loading-more-indicator') === null) {
                const loadingMore = document.createElement('div');
                loadingMore.className = 'loading-more-indicator';
                loadingMore.style.cssText = 'padding: 12px; text-align: center; color: var(--text-tertiary); font-size: 11px;';
                loadingMore.textContent = 'Scroll for more...';
                listEl.appendChild(loadingMore);
            } else if (!columnData[pattern].hasMore) {
                const loadingMore = listEl.querySelector('.loading-more-indicator');
                if (loadingMore) {
                    loadingMore.remove();
                }
            }
        }

        async function loadAllColumns() {
            const patterns = ['adj_noun', 'verb_noun', 'prep', 'adverb_verb', 'temporal', 'compound', 'emotional'];
            
            // Set the pattern count in header (hardcoded - total of all pattern types)
            let totalPatterns = 55171 + 113103 + 145139 + 49161 + 5995 + 31111 + 4433;
            document.getElementById('total-patterns').textContent = totalPatterns.toLocaleString();
            
            // Fetch dream count (non-blocking)
            supabase
                .from('dreams')
                .select('*', { count: 'exact', head: true })
                .then(({ count }) => {
                    if (count) {
                        document.getElementById('total-dreams').textContent = count.toLocaleString();
                    }
                })
                .catch(err => console.error('Error fetching dream count:', err));
            
            // Load all columns
            await Promise.all(patterns.map(p => loadColumn(p)));
        }

        function collapseAll() {
            const columns = document.querySelectorAll('.column');
            columns.forEach(col => {
                col.classList.remove('expanded', 'collapsed', 'active');
            });
        }

        async function expandColumn(pattern, selectedItem) {
            const columns = document.querySelectorAll('.column');
            const selectedColumn = document.querySelector(`.column[data-pattern="${pattern}"]`);
            
            columns.forEach(col => {
                col.classList.remove('expanded', 'active');
                col.classList.add('collapsed');
            });
            
            selectedColumn.classList.remove('collapsed');
            selectedColumn.classList.add('expanded', 'active');
            
            await displayDreams(pattern, selectedItem);
        }

        async function displayDreams(pattern, phrase) {
            const viewEl = document.getElementById(`dreams-${pattern}`);
            viewEl.innerHTML = '<div class="loading-indicator">Loading dreams...</div>';
            
            try {
                const dreams = await getDreamsByPattern(pattern, phrase);
                
                let html = `
                    <div class="back-button" onclick="collapseAll()">← back to all columns</div>
                    <div class="dreams-header">
                        <div class="selected-phrase">${escapeHtml(phrase)}</div>
                        <div class="dreams-meta">${dreams.length} DREAM${dreams.length !== 1 ? 'S' : ''}</div>
                    </div>
                `;
                
                dreams.forEach(dream => {
                    const highlighted = highlightPhrase(dream.text, phrase);
                    html += `
                        <div class="dream-card">
                            <div class="dream-card-header">
                                <span class="dream-label">Dream</span>
                                <span class="dream-id">#${(dream.id + 1).toString().padStart(5, '0')}</span>
                            </div>
                            <div class="dream-text">${highlighted}</div>
                        </div>
                    `;
                });
                
                viewEl.innerHTML = html;
                viewEl.scrollTop = 0;
            } catch (error) {
                console.error('Error displaying dreams:', error);
                viewEl.innerHTML = '<div class="loading-indicator">Error loading dreams</div>';
            }
        }

        function highlightPhrase(text, phrase) {
            const escaped = escapeHtml(text);
            const lower = text.toLowerCase();
            const lowerPhrase = phrase.toLowerCase();
            const parts = [];
            let lastIdx = 0;
            let idx = lower.indexOf(lowerPhrase);
            
            while (idx !== -1) {
                if (idx > lastIdx) parts.push(escaped.substring(lastIdx, idx));
                const match = text.substring(idx, idx + phrase.length);
                parts.push(`<span class="highlight">${escapeHtml(match)}</span>`);
                lastIdx = idx + phrase.length;
                idx = lower.indexOf(lowerPhrase, lastIdx);
            }
            
            if (lastIdx < escaped.length) parts.push(escaped.substring(lastIdx));
            return parts.join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ======= EVENT HANDLERS =======
        document.querySelectorAll('.column-header').forEach(header => {
            header.addEventListener('click', function(e) {
                const anyExpanded = document.querySelector('.column.expanded');
                if (anyExpanded) {
                    collapseAll();
                }
            });
        });

        document.getElementById('universal-search').addEventListener('input', function(e) {
            const anyExpanded = document.querySelector('.column.expanded');
            if (anyExpanded) {
                collapseAll();
            }
            universalSearch = e.target.value;
            // Reload all columns with search
            Object.keys(columnData).forEach(pattern => {
                columnData[pattern].loaded = false;
                columnData[pattern].offset = 0;
                columnData[pattern].patterns = [];
                columnData[pattern].aggregated = new Map();
                columnData[pattern].hasMore = true;
                columnData[pattern].loading = false;
            });
            loadAllColumns();
        });

        // Alphabetical sort button - toggles between ascending and descending
        document.getElementById('sort-alphabetical').addEventListener('click', function() {
            const anyExpanded = document.querySelector('.column.expanded');
            if (anyExpanded) {
                collapseAll();
            }
            
            // Toggle between ascending and descending
            const directionEl = document.getElementById('sort-direction');
            if (universalSort === 'alpha') {
                universalSort = 'alpha_desc';
                directionEl.textContent = '↑';
            } else {
                universalSort = 'alpha';
                directionEl.textContent = '↓';
            }
            
            // Update active state
            document.querySelectorAll('.universal-sort-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            // Reload all columns with new sort
            Object.keys(columnData).forEach(pattern => {
                columnData[pattern].loaded = false;
                columnData[pattern].offset = 0;
                columnData[pattern].patterns = [];
                columnData[pattern].aggregated = new Map();
                columnData[pattern].hasMore = true;
                columnData[pattern].loading = false;
            });
            loadAllColumns();
        });

        // Frequency sort button
        document.getElementById('sort-frequency').addEventListener('click', function() {
            const anyExpanded = document.querySelector('.column.expanded');
            if (anyExpanded) {
                collapseAll();
            }
            
            universalSort = 'freq';
            
            // Update active state
            document.querySelectorAll('.universal-sort-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            
            // Reload all columns with new sort
            Object.keys(columnData).forEach(pattern => {
                columnData[pattern].loaded = false;
                columnData[pattern].offset = 0;
                columnData[pattern].patterns = [];
                columnData[pattern].aggregated = new Map();
                columnData[pattern].hasMore = true;
                columnData[pattern].loading = false;
            });
            loadAllColumns();
        });

        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                collapseAll();
            }
        });

        // ======= INITIALIZATION =======
        async function init() {
            // Check if Supabase is configured
            if (SUPABASE_URL === 'YOUR_SUPABASE_URL' || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                alert('Please configure your Supabase credentials in the HTML file. See the README for instructions.');
                return;
            }
            
            // Load all columns (this will set the counts)
            await loadAllColumns();
        }

        // Start the app
        init().catch(error => {
            console.error('Error initializing app:', error);
            alert('Error connecting to database. Please check your Supabase configuration and console for details.');
        });
    </script>
</body>
</html>

